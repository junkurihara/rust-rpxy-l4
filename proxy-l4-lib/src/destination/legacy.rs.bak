//! Legacy destination types
//!
//! This module contains destination functionality that is still needed for compatibility
//! but may be deprecated in future versions.

use crate::{config::EchProtocolConfig, error::ProxyBuildError, target::DnsCache};
use std::sync::Arc;

/* ---------------------------------------------------------- */
/// Load balancing policy
/// Note that in the `SourceIp` and `SourceSocket` policies, a selected servers
/// for a source IP/socket might differs when new [Destination] is created.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum LoadBalance {
  /// Choose a server by the source IP address
  /// If the source IP is not changed, the same backend will be selected.
  SourceIp,

  /// Choose a server by the source socket address (IP + port).
  /// Even if the source IP is not changed, the same backend might not be selected when the source port is different.
  SourceSocket,

  /// Randomly select a server
  Random,

  #[default]
  /// Always select the first server [default]
  None,
}

impl TryFrom<&str> for LoadBalance {
  type Error = ProxyBuildError;
  fn try_from(value: &str) -> Result<Self, Self::Error> {
    match value {
      "source_ip" => Ok(LoadBalance::SourceIp),
      "source_socket" => Ok(LoadBalance::SourceSocket),
      "random" => Ok(LoadBalance::Random),
      "none" => Ok(LoadBalance::None),
      _ => Err(ProxyBuildError::invalid_load_balance(value.to_string())),
    }
  }
}

/* ---------------------------------------------------------- */
#[derive(Clone, Debug, Default)]
/// TCP/UDP destinations + EchProtocolConfig
pub struct TlsDestinationItem<T> {
  /// Destination (UdpDestination or TcpDestination)
  /// If ECH decryption is failed (no matched ECH config), this destination will be used as the default destination
  dest: T,
  /// EchProtocolConfig
  ech: Option<EchProtocolConfig>,
  /// DnsCache
  dns_cache: Arc<DnsCache>,
}

impl<T> TlsDestinationItem<T> {
  /// Create a new instance
  pub fn new(dest: T, ech: Option<EchProtocolConfig>, dns_cache: Arc<DnsCache>) -> Self {
    Self { dest, ech, dns_cache }
  }
  /// Get the destination
  pub fn destination(&self) -> &T {
    &self.dest
  }
  /// Get the ECH config
  pub fn ech(&self) -> Option<&EchProtocolConfig> {
    self.ech.as_ref()
  }
  /// Get the DNS cache
  pub fn dns_cache(&self) -> &Arc<DnsCache> {
    &self.dns_cache
  }
}
